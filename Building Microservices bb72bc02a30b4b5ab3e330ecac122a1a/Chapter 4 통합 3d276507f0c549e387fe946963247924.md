# Chapter 4. 통합

**통합에 대한 올바른 이해는 마이크로서비스 관련 기술에서 가장 중요한 요소이다.**

# 이상적인 통합 기술 모색

하나의 마이크로서비스가 다른 마이크로서비스와 통신하는 방법은 매우 다양하다. (ex : SOAP, XML-RPC, REST, 프로토콜 버퍼, etc...) 

## 호환성을 깨뜨리는 변경 피하기

마이크로 서비스가 데이터 일부분에 새로운 필드를 추가해서 노출하더라도 기존 서비스에는 영향을 미치지 않아야 한다.

## 기술 중립적인 API 생성

IT 업계는 빠르게 변화한다. 마이크로서비스 간의 통신에 사용되는 AIP가 특정 기술에 종속되지 않도록 기술 중립성을 유지하는것이 매우 중요하다.

## 소비자를 위한 서비스 단순화

클라이언트 라이브러리를 제공하는 것이 유용해 보일 수 있으나, 이는 결합 비용의 증가를 초래한다.

## 내부 구현 상세 감추기

소비자가 서비스 내부 구현에 종속되면 결국 결합도가 높아지고, 내부를 변경하려 할 때도 소비자에게 변경을 요구하며 호환성을 깨뜨릴 수 있다.

# 공유 데이터베이스

가장 일반적인 통합 형태는 DB통합이다. 이는 충분히 일반적인 패턴이지만 일부 어려움이 있다.

- 외부에서 내부의 구현 상세를 조회하고 결합하는 것을 허용하게된다.
- DB에 접근하는 모든 대상에게 DB에 저장되어 있는 데이터 구조 전체가 공유된다.
- 소비자들이 특정 기술을 선택하는 범위가 제한된다.
- 소비자가 DB를 직접 조작한다면 소비자는 관련 로직을 직접 소유해야 하고, 같은 종류의 조작을 수행하는 로직이 다수의 소비자에게 퍼지게 되고, 이는 응집력이 낮아진다.
- 강한 응집력과 느슨한 결합 모두를 잃게된다.

# 동기와 비동기

동기/비동기에 대한 선택은 특정 세부 구현을 이끈다.

- 요청/응답 모델 : 동기 방식과 일치하지만 비동기에서도 잘 동작한다. 클라이언트는 요청을 보내고 그 작업이 완료되었을 때 서버가 알려주도록 요청하는 콜백을 등록할 수 있다.
- 이벤트 기반 모델 : 클라이언트는 완료되어야 할 작업을 요청하는 대신 일이 발생했음을 알린다. 아래의 특징을 갖는다.
    - 다른 누구에게도 해야 할 일을 말하지 않는다.
    - 비즈니스 로직이 핵심 두뇌로 집중화되기보다는 다양한 협업자들에 고르게 분배된다.
    - 매우 결합도가 낮다.
    - 이벤트 퍼블리셔는 이벤트에 반응하는 대상이 누구인지 혹은 무엇인지 젼혀 알지 못한다.

위 모델중 특정 방식을 선택하게하는 요인은 바로 복잡하고 잦은 문제를 해결하는데 얼마나 적합한가 이다.

# 오케스트레이션과 코레오그래피

## 오케스트레이션

- 오케스트라 지휘자처럼 프로세스를 안내하고 구동하는 하나의 중앙 두뇌에 의존
- 특정 서비스에 지나치게 많은 중앙 관리 권한이 부여되는 단점 존재.

## 코레오그래피

- 발레 무용수들이 자신의 역할을 알고 주변의 다른 무용수들에 반응하는것처럼 시스템 각 부분에 작업 내용을 알리고 세부 사항을 수행하게 한다. (이벤트만 발산할 뿐이다.)
- 비즈니스 프로세스의 명확한 뷰와 반대로 시스템에 암시적으로 반영되는 단점 존재. (일이 제대로 수행되는지 모니터하고 추적하기 위한 추가 작업이 필요하다.)

# 원격 프로시저 호출(RPC)

요청/응답 모델을 고려할 때 아주 적합한 기술 중 하나이다. 지역 호출을 통해 원격 서비스를 실행하게 된다. 

## 장점

### 빠른구현

- RPC 구현체들은 빠르게 시작할 수 있는 클라이언트와 서버 스텁을 생성하게 한다.

### 쉬운 사용성

- 네트워크 경계를 넘어 즉시 데이터를 보낼 수 있다.

### 손쉬운 사용

- 일반적인 메소드 호출처럼 사용하고, 이론적으로 다른 것은 신경 쓰지 않아도 된다.

## 단점

### 기술 결합

- 자바 RMI와 같은 일부 RPC는 특정 기술과 지나치게 얽혀있어 클라이언트와 서버에 사용될 기술을 제한한다.

### 지역 호출은 원격 호출과 다르다

- RPC 의 핵심은 원격 호출의 복잡성을 은폐하는 것이나 수많은 RPC 구현체들은 이를 지나치게 은폐한다.
- 원격 인터페이스와 지역 인터페이스에 대한 API 디자인을 별개로 생각해야 한다.

### 취성(쉽게 깨지거나 부서지는 성질)

- 서버 스텁에 새로운 메서드를 쉽게 추가 할 수 있으나. 클라이언트 스텁도 다시 생성해야 한다.
- 필드 변경 시 클라이언트와 서버를 동시에 배포해야 한다.

# REST

RPC와 더불어 요청/응답 모델을 고려할 때 아주 적합한 기술 중 하나이다.

## REST와 HTTP

- HTTP는 자체적으로 REST 방식과 궁합이 맞는 유용한 기능들을 정의한다. (ex : GET, POST, DELETE, PUT 과 같은 HTTP 동사들)
- HTTP는 지원 도구와 기술의 거대한 생태계를 제공한다(ex : HTTP 캐시 프록시, 로드밸런서, 모니터링 도구)

## HATEOAS

- 고객과 웹사이트 간에 암묵적 계약이 존재하는 한 웹페이지의 수정은 호환성을 깨드리는 변경이 되지 않는다.
- 클라이언트는 링크를 따라가면서 점진적으로 API를 발견하게 되는데, 새로운 클라이언트를 구현할 때 유용하다.

## Json VS XML

- Json이 상대적으로 간소하다
- XML은 link 컨트롤을 하이퍼미디어 컨트롤로 정의하지만 Json 표준은 자체 방식을 사용한다. (HAL 스펙은 Json과  XML에 공통 표준을 정의하여 문제를 해결한다)
- HTTP 상으로 어떤것이든 전송 할 수 있다.
- 일부 도구의 지원은 XML이 더 좋다. (ex : Payload의 특정 부분 추출할때)

## 지나친 편의를 주의하라

- RESTful 웹 서비스 생성을 도와주는 프레임워크가 인기를 얻고 있는데, 작업 속도를 높일 수는 있겠지만 몇 가지 나쁜 행동을 범하게 된다.
- 일부 프레임워크는 객체의 데이터베이스 표현을 바로 전달받아 프로세스 내의 객체로 역직렬화하고, 외부로 직접 노출하는 일련의 작업을 매우 쉽게 만들어버린다.
- 데이터를 어떻게 저장할 것인가 그리고 어떻게 소비자에게 노출시킬 것인가를 고민 해야 한다.

## 단점

- 클라이언트 스텁이 RPC처럼 쉽게 생성되지 않는다.
- 일부 웹 서버 프레임워크가 실제로는 모든 HTTP 메서드를 제대로 지원하지 않는다.
- 성능 문제
    - HTTP 기반의 REST 페이로드는 JSON 또는 바이너리 등의 포맷을 지원하므로 SOAP보다 훨씬 간결할 수 있지만 쓰리프트와 같은 바이너리 프로토콜에는 상대가 되지 못한다.
    - 각각의 HTTP 요청에서 늘 발생하는 HTTP 부하 역시 낮은 지연시간이 요구될 때 문제가 될 수 있다.
- HTTP가 대규모 트래픽에는 적합할 수 있지만 TCP 또는 다른 네트워킹 기술 기반의 대체 프로토콜과 비교하면 낮은 지연시간이 필요한 통신에는 좋은 선택이라 할 수 없다. (ex : 웹소켓)

# 비동기 이벤트 기반의 협업 구현

## 기술 선택

- 마이크로서비스가 이벤트를 발산하는 방법, 소비자가 생성된 이벤트를 찾는 방법을 고려해야 한다.
- 미들웨어를 멍청하게, 엔드포인트를 지능적으로 만들어라.
- RabbitMQ
    - 생산자는 API를 사용하여 브로커(중개자)에게 이벤트를 발행하고 브로커는 이벤트가 도착하면 소비자에 알릴 수 있도록 구독을 처리한다.
    - 중개자는 소비자 상태도 처리하는데, 소비자가 이전에 확인했던 메시지를 추적할 수 있도록 돕는다.
    - 중개자 시스템은 대개 확장 및 회복이 가능하도록 설계되어 있지만 또 다른 시스템인 만큼 개발 과정의 복잡성이 높아진다.
- HTTP(ATOM 사용)
    - ATOM: 웹로그나 최신 소식고 같은 웹 콘텐트의 신디케이션을 위한 XML 기반의 문서 포맷이자 웹로그 편집을 위한 HTTP 기반 프로토콜이다.
    - 서비스는 변경될 때 해당 피드에 대한 이벤트만 발행하고, 서비스의 소비자들은 단지 피드의 변경이 있는지 폴링만 하면 된다.
    - 경쟁 소비자 패턴에서 작업자를 늘리면 중복 작업의 가능성을 낮추도록 모든 작업자 간에 공유 상태를 관리하는 것이 필요하다.

    ## 비동기 아키텍처의 복잡성

    - 장기간 수행되는 비동기 요청/응답의 경우 응답이 돌아올 때 무엇을 해야 할지 고민해야 한다.
        - 요청을 시작했던 동일한 노드로 응답이 돌아오는가?
        - 그렇다면 그 노드가 다운된다면 어떻게 할 것인가?
        - 그렇지 않다면 요청/응답의 정보를 저장해서 적절히 동작할 수 있는가?
    - 재앙적 대체 작동이 발생하지 않도록 신경써야 한다.
    - 적재적소에서 모니터링하고 프로세스 경계 요청을 추적할 수 있도록 상관관계 ID의 사용을 적극 검토해야 한다.

    # 스테이트 머신으로서의 서비스

    - 고객 서비스는 자신의 로직을 기반으로 해서 요청의 수용 여부를 결정하고, 해당 고객과 연관된 이벤트의 수명주기를 통제한다.
    - 단순한 CRUD 래퍼처럼 멍청하고 빈약한 서비스를 원하지 않는다.
    - 고객 정보 변경에 관한 결정이 고객 서비스 외부에서 이뤄진다면 응집력을 잃은 것이다.

    # 반응형 확장

    - Rx로 알려진 반응형 확장은 다수의 호출 결과를 조합하고 그 결과에 따라 연산을 실행하는 메커니즘이다.
    - 더 많은 서비스를 호출하게 될 때, 특히 하나의 작업을 수행하기 위해 다수의 호출일 필요할 때 사용하면 좋다.
    - 데이터를 요청하는 대신 데이터에 대한 연산을 수행하고, 그 연산의 결과를 관찰하며, 변경에 따라 반응한다.
    - 분산 시스템은 호출 방법의 구현 세부 사항을 추상화하고 더 쉽게 추론하게 하므로 Rx 구현체와 아주 잘 어울린다. 하위 서비스에 대한 호출 결과를 관찰해보면 클라이언트는 그 호출이 블로킹 또는 논블로킹인 것에 관계없이 응답을 기다리고 반응할 뿐이다.
    - Rx의 백미는 하위 서비스에 대해 동시에 발생하는 호출들을 훨씬 쉽게 처리하면서 다수의 호출을 함께 조합할 수 있다는 것이다.

# 마이크로서비스 세계에서 코드 재사용의 위험과 DRY

DRY: 시스템의 행동양식과 지식의 중복을 회피하는 모든 시도

- 공유 코드를 서비스 경계를 넘어서 사용한다면 잠재적인 결합의 문제를 안고 있는 셈이다.
    - 공용 도메인 객체들의 라이브러리를 사용하다가 변경사항이 있을 경우 전체 서비스를 업데이트해야 한다.
- 하지만 로깅 라이브러리와 같은 공통 코드는 외부에서는 보이지 않는 내부의 개념이므로 사용해도 문제없다.
- 강한 결합으로 인해 생기는 문제가 코드 중복이 초래하는 문제보다 더 심각하다.

### 클라이언트 라이브러리

- 클라이언트 라이브러리에 더 많은 로직이 스며들수록 응집력이 더 많이 무너진다.
- 서비스 발견과 서비스 실패등을 처리하는 하부 전송 계층의 클라이언트 코드를 목적지인 서비스 자체의 것들과는 분리하는 것이 중요하다.
- 하부 API 호출을 위해 클라이언트 라이브러리의 사용을 강조할지 아니면 다른 기술 스택을 허용할 것인지 결정해야 한다.
- 클라이언트 라이브러리의 업데이트 시점을 클라이언트가 담당하게 한다. 각 서비스를 항상 독집적으로 릴리스 할 능력을 유지해야 한다.

# 참조에 의한 접근

- 메모리에 오래 두면 변경 사항이 있을 수도 있으므로, 당시 도메인 개체의 내용이 담긴 메모리를 전달하는 결정과 관계없이 자원의 새로운 상태를 확보할 수 있도록 원본 자원의 참조도 포함해야 한다.
- 이벤트 발생 자체뿐만 아니라 무슨 일이 일어났는지도 알아야 한다.
- 이벤트가 발생했을 때 Customer가 어떤 상태였는지 아는 것이 중요하다.
- 개체에 대한 참조를 유지한다면 개체의 현재 상태를 알 수 있다.
- 접근이 많아지므로 부하가 매우 커질 수 있다.
    - 자원이 추출되는 시점에 언제 리소스가 특정 상태가 되는지와 정보 갱신에 얼마나 오랜 시간이 소요되는지 알 수 있는 부가 정보가 제공된다면 캐시를 통해 부하를 줄이기 위한 많은 일을 할 수 있다.
    - HTTP는 기본적으로 다양한 캐시 컨트롤을 통해 많은 지원을 한다.
- Customer 자원 전부를 알 필요가 없는데도 해당 자원의 검색을 주장하며 잠재적으로 결합도가 증가된다.
    - 여기에는 고정불변의 법칙은 없지만, 데이터의 갱신 시점을 알 수 없는 경우라면 요청에 데이터를 삽입해서 주고받는 것을 매우 조심해야 한다.

    # 버전 관리

    ## 가능하면 지연하기

    - 알 수 없는 데이터는 무시하고 필요한 데이터만을 추출하며, 데이터 구조의 변경 을 예상하도록 설계한다.(관대한 독자(Tolerant Reader) 패턴)

    ## 호환성을 깨뜨리는 변경 일찍 찾아내기

    - 문제를 일찍 발견할 수 있도록 소비자 주도 계약(CDC)를 강력히 한다.

    CDC : 서비스를 진화하기 위한 패턴으로, 각 소비자는 서비스 공급자에게 기대하는 사항을 개별 계약으로 캡처하고 공급자와 공유한다.

    - 소비자를 고장낼 것 같으면 그것을 피할지 아니면 수용할지 다 함께 결정하고 소비자 서비스 담당자들과 적절한 대화를 시작해야 한다.

    ## 유의적 버전 관리

    - 클라이언트가 서비스의 버전 번호만 보고도 해당 서비스와 통합 가능한지 알 수 있도록 하는 명세이다.
    - MAJOR.MINOR.PATCH 형태가 된다.
        - MAJOR : MAJOR 버전 번호의 증가는 하위 호환성이 깨진 변경이 발생했음을 의미한다.
        - MINOR : MINOR 버전 번호의 증가는 하위 호환성을 유지하면서 새로운 기능들이 추가되었음을 의미한다.
        - PATCH : PATCH 번호의 증가는 기존 기능의 버그를 수정했다는 것을 의미한다.
    - 이러한 접근 방식은 분산 시스템 분야에서는 자주 쓰이지 않는다.

    ## 다른 엔드포인트와 공존

    - 호환성을 깨뜨리는 변경을 릴리스하고 싶다면 구버전, 신버전의 엔드포인트를 모두 노출하는 새로운 서비스 버전을 배포해야 한다.
    - 구 소비자들이 신식 방법을 따른다면 이전 기능을 제거하고 API를 축소한다.
    - 여러 버전의 엔드포인트가 공존할 때 호출자가 그들의 요청을 적절히 라우팅할 방법을 고려해야 한다.
        - HTTP를 사용하는 시스템에서 버전 정보를 요청 헤더에 삽입
        - /v1/customer/, /v2/customer/ 와 같이 URI에 삽입

    ## 다수의 병행 서비스 버전 사용하기

    - 다양한 버전의 서비스를 동시에 실행하고 구 소비자의 트래픽을 구버전에, 신규 소비자를 신버전에 라우팅한다.
    - 넷플릭스가 여간해서 이 방법을 사용하지 않는 이유
        - 한 서비스의 내부 버그를 고치려면 두 서비스를 수정하고 배포해야 한다.
        - 소비자가 찾는 서비스로 유도하기 위한 부가적인 로직이 필요하다.
        - 필연적으로 미들웨어의 특정 장소 or 다수의 nginx 스크립트 등에 추가되어 시스템 동작을 유추하기 어렵게 만든다.
        - 그 서비스가 처리해야 할 영속적(저장할) 상태가 있는지 고려해야 한다.

    # 사용자 인터페이스(UI)

    ## 디지털을 향해

    - 고객이 우리와 어떻게 상호작용할지 정확히 예측할 수 없기에 더 세분화된 API가 필요하다.
        - 서비스들이 다양한 방식으로 노출하는 기능들을 서로 결합시킴으로써 데스크톱 애플리케이션, 모바일 기기, 웨어러블 기기의 사용 고객뿐만 아니라 오프라인 상점을 방문하는 등의 물리적 방식을 사용하는 고객에게도 다양한 경험을 심어줄 수 있다.
    - 사용자 인터페이스는 우리가 제공하는 다양한 기능요소를 한데 엮을 수 있는 구성 가능한 계층이다.

    ## 제약

    - 제약은 사용자가 시스템과 상호작용하는 또 다른 형태다.
    - 데스크톱 웹 애플리케이션에서는 브라우저 종류, 해상도의 제약이 있고 모바일에는 완전히 새로운 제약들이 존재한다.
    - 딘순히 모바일 네트워크의 한계에 따른 제약 사항인 대역폭 문제에 국한되지 않는다.
        - 다양한 종류의 상호작용이 배터리 수명을 단축시키고 고객을 화나게 만든다.
    - 상호작용의 성질이 달라진다.
        - 태플릿에서는 PC처럼 쉽게 오른쪽 버튼 클릭을 할 수 없다.
        - 모바일 폰에서는 대부분 동작을 엄지손가락으로 수행하며 한 손으로 사용 가능한 인터페이스를 원할 것이다.
        - 한편 네트워크 대역이 아주 귀한 곳에서 사람들은 SMS를 통해 서비스와 상호작용하도록 허용할 수 있다.
    - 따라서 핵심 서비스들이 동일하더라도 각 인터페이스의 다양한 제약에 따라 그 서비스들을 적절히 적용할 방법이 필요하다.

    ## API 구성

    - UI가 직접 다수의 API와 통신하는 방식일 경우에 아래와 같은 제약이 있다.
        - 다양한 종류의 디바이스에 맞춤화된 응답 능력이 거의 없다.
        - 서비스 담당자들은 그들의 서비스가 사용자에게 보여지는 방식에 대해 관여하지 않는다.
            - 다른 팀이 UI를 생성한다면 작은 변경 하나도 여러 팀에 요청해야 한다.
        - 꽤 많은 호출이 있을 수 있다. 서비스에 직접적으로 수많은 호출을 하는 것은 모바일 기기에 꽤 부담이 될 수 있고 더 많은 모바일 요금을 초래할 수도 있다.
        - 다수의 하부 호출을 모아 외부로 호출할 수 있는 API 게이트웨이를 사용하면 도움이 될 수 있다.

    ## UI 부분 구성

    - UI가 API를 호출하고 UI 컨트롤과 매핑하는 대신 서비스들이 UI 생성에 필요한 일부 UI를 직접 제공할 수 있다.
    - 큰 단위의 UI 부분을 서버 측 애플리케이션으로부터 제공한다.
    - UI 부분들을 한 곳에 구성할 수 있는 조립 계층이 필요하다.
        - 조립 계층은 서버 측 템플릿처럼 단순하거나 다른 애플리케이션으로 전달되는 페이지들의 집합이 될 수 있다. 후자의 경우 정교한 URI 라우팅이 필요하다.
    - 일정 수준의 일관성을 유지하도록 HTML 컴포넌트, CSS, 이미지 등의 asset을 공유할 수 있다.
    - UI 컴포넌트를 제공할 수 없는 네이티브 애플리케이션 또는 무거운 클라이언트에 대한 경우를 생각해야 한다. (하이브리드 방식, 반응형 컴포넌트 개발)
    - 교차 형태의 상호작용이 많을수록 이 모델은 적절하지 않으며, 단순히 API 호출 하는 방식으로 회귀할 가능성이 높다.

    ## 프론트엔트를 위한 백엔드

    - 일반적인 해결책은 서버 측의 집합 엔드포인트 또는 API 게이트웨이를 제공하는 것이다.
        - 다수의 백엔드 호출을 마샬링할 수 있고 서로 다른 종류의 디바이스를 위해 필요하다면 콘텐트에 변화를 주거나 집계하여 표현할 수 있다.
        - 하지만 서버 측 엔드포인트가 너무 많은 동작을 하며 계층이 두터워지면 그 계층은 결국 별도의 팀에 의해 관리되고, 일부 기능이 변경될 때마다 로직도 바뀌어야 한다.
        - 모든 서비스에 대한 거대한 단일 계층이 될 수 있는 문제가 있다.
    - 프론트엔드를 위한 백엔드(BFF)라고 하는 패턴에서는 특정 UI에 집중하는 팀이 해당 서버 측 컴포넌트도 담당한다.
        - API 인증 및 권한 계층이 필요하다면 BFF와 UI 사이에 배치될 수 있다.
        - 이 방법의 위험성은 포함해서는 안 되는 로직을 포함할 수 있는 집합 계층의 위험성과 유사하다.
        - 따라서 백엔드가 사용하는 다양한 기능의 비즈니스 로직은 서비스에 존재해야하고 BFF는 특정 사용자 경험을 제공하기 위한 행동양식만 포함해야 한다.

    ## 하이브리드 방식

    - 웹사이트에는 부품 기반의 조립 방식을 사용하고, 모바일에는 BFF 방식을 적용하는 조직도 있다.
    - 사용자에게 제공하는 하부 기능들의 응집력을 유지해야 한다.
    - 음반을 주문하거나 고객 세부 정보를 변경하는 것과 관련한 로직은 시스템 전체에 흩어지지 않으면서 해당 작업을 처리하는 서비스 내에 상주하도록 해야 한다.
    - 하지만 지나치게 많은 행위를 중간 계층에 집어넣으려는 유혹을 피하는 것은 균형을 유지하기 어려운 과정이다.

    # 마치며

    - 데이터베이스 통합은 최대한 피하라.
    - REST와 RPC의 장단점을 이해하고 요청/응답을 통합하는 좋은 출발점으로 REST를 고려하라.
    - 오케스트레이션보다는 코레오그래피를 우선하라.
    - 포스텔의 법칙을 이해하고 관대한 독자패턴을 사용해서 호환성을 깨뜨리는 변경과 불필요한 버전을 피하라.
    - 구성 계층으로서의 사용자 인터페이스를 생각하라.


--- 
참고 

http://aeternum.egloos.com/category/Domain-Driven%20Design

https://docs.microsoft.com/ko-kr/dotnet/architecture/microservices/

https://www.youtube.com/watch?v=RP_f5dMoHFc
